---
globs: app/**/*.vue
alwaysApply: false
---
# Vue Component Rules

Rules for authoring Vue SFCs in this project.

## Component Design Principles

- Keep one responsibility per component; move reusable logic to `app/composables` or domain modules.
- Import components explicitly; never rely on Nuxt auto-import.
- Split components once they exceed rendering + light orchestration.

## Script Setup Essentials

- Use TypeScript and place a JSDoc summary right under `<script setup>`.
- Prefer `useTemplateRef(key)` over `ref(null)` for template refs.
- Annotate computed values when inference fails: `computed<Result>(() => ...)`.
- Invoke composables synchronously at the top level of `<script setup>`.

## Props

- Declare props with type-based `defineProps` and JSDoc every field.
- Use `withDefaults` for optional primitives; hoist object/array defaults to constants.
- Avoid boolean tri-state; use explicit unions when options are finite.
- Narrow to literal unions instead of broad `string` for domain values.

## Emits & Events

- Define events with typed `defineEmits`.
- Reserve `update:propName` for prop mirroring without `defineModel`.
- Emit lean, typed payloads (IDs over whole objects unless required).

## Models (`defineModel`)

- Use `defineModel` only when the component owns two-way state (e.g., `v-model:selected`).
- Name multiple models explicitly (`defineModel<string>('query')`) and document purpose + side effects.
- JSDoc each model variable with usage and emit timing.

## Slots

- Declare slots with `defineSlots` for type safety.
- Keep slot props stable; use optional fields instead of shape changes.

## Reactivity & Watchers

- Prefer `computed` for derivations instead of manual assignment.
- Use `watch(source, ...)` sparingly; reach for `watchEffect` only when dependencies are dynamic. Explain any `deep: true` usage.

## Attribute Forwarding

- Forward attributes by default when wrapping a single native element.
- If filtering attributes, set `defineOptions({ inheritAttrs: false })`, bind `v-bind="attrs"`, and document anything dropped.

## Template Rules

- Use semantic HTML and skip redundant `role` attributes.
- Provide stable `:key` values from domain IDs; avoid loop indices for mutable lists.
- Use `v-show` for toggles and `v-if` when mount/unmount is desired.
- Hoist object/array literals out of hot template paths.
- Add `loading="lazy"` to images that are not immediately needed.
- Use `<time>` for time data and pass route objects to `<NuxtLink :to="{ name: 'route-name' }">`.
- Access props in templates as `props.x` for consistency.
- Avoid `tw()` helpers in <template>; use Tailwind classes directly.

## Accessibility

- Ensure every interactive element has a name (`label`, `aria-label`, or `aria-labelledby`).
- Manage focus when UI context moves (dialogs, ephemeral notifications, etc.).
- Avoid `tabindex` > 0; rely on DOM order and mirror pointer interactions on keyboard.
- Mark long-running regions with `aria-busy` during partial async updates.

## Async & Error Handling

- Wrap async flows in dedicated functions that expose `loading / error / data` states.
- Map errors to domain-friendly messages in `try/catch`; never surface raw network errors.
- Dispose timers and subscriptions with `onScopeDispose`.

## SSR & Hydration

- Keep `<script setup>` SSR-safe: no browser-only APIs unless gated by `import.meta.client` with identical output; otherwise defer to `onMounted`.
- Fetch initial data with SSR composables (`useAsyncData`, `useFetch`, `useState`) instead of ad-hoc requests.
- Precompute nondeterministic values via `useState('key', () => ...)` or update after mount; never inline randomness in SSR output.
- Avoid template branches driven by client-only state; use responsive CSS or `<ClientOnly>` with an accessible fallback.
- Wrap client-only widgets in `<ClientOnly>` and keep fallbacks semantic and non-interactive.
- Delay DOM-mutating libraries to `onMounted` (optionally with dynamic `import()`); keep setup pure.
- Place timers and listeners inside lifecycle hooks to prevent hydration drift.
- Treat hydration mismatch warnings as blockers; investigate immediately.

## Performance

- Use `v-once` / `v-memo` for static or rarely changing fragments.
- Hoist handlers outside `v-for` hot paths.
- Provide stable primitive or ID keys and defer expensive computation until needed.
- Keep prop inputs stable by hoisting object/array/function literals.
- Lazy-load heavy children via the `Lazy` prefix and consider lazy hydration (`hydrate-on-visible`, etc.) for off-screen interactions.
- Stage images: raise priority only for key visuals; use `loading="lazy"` on deferable media.
- Gate third-party scripts; initialize analytics via Nuxt Scripts or in `onMounted`.
- Revisit plugins regularly and migrate simple logic to composables.
- Code-split large dependencies and confirm impact with `nuxi analyze`.

## Styling

- Prefer Tailwind utilities; only add `<style>` for third-party overrides, complex animation, or selectors unavailable in utilities. Preface with a comment.
- Keep class lists readable; extract repeated sets into components or utilities.

## Testing

- Atoms: cover render, accessible name/role, primary interaction, disabled/variant logic.
- Molecules: cover edge states (empty, large, error), slots, emitted payload shape.
- Prefer semantic queries over snapshots; assert behavior, not internals.

## Antiâ€‘Patterns (Avoid)

- Overusing `watchEffect` instead of dependency `watch`.
- Using loop indices as keys for mutable lists.
- Emitting events that mirror prop names without the `update:` prefix.

## When In Doubt

- Favor explicitness (typed props/emits, stable keys, documented intent) over clever abstractions.
- Extract before complexity spreads; small focused composables improve reuse & testability.
